CW Practice

select MIN(age) as age_min, MAX(age) as age_max from people

SELECT 
  DATE(created_at) as day,
  description,
  COUNT(*)
FROM events
where name LIKE ('trained')
GROUP BY DATE(created_at), description


select capital from countries where continent  IN ('Africa','Afrika') and country LIKE 'E%' order by capital LIMIT 3


select * from books order by copies_sold desc limit 5

select * from travelers where country NOT IN ('USA','Canada','Mexico')









































insert into users (id, first_name, last_name, birthday)
values (9, "Антон", "Пепеляев", "1992-07-12")
============================================

insert into users SET id=10, first_name="Никита", last_name="Петров"
============================================

insert into products (id, name, count, price)
values
(8,"iPhone 7", 1, 59990),
(9,"iPhone 8", 3, 64990),
(10,"iPhone X", 2, 79900);
============================================

update orders set status = "new" where status is NULL

============================================

delete from products where count = 0;

============================================
CREATE TABLE users2 (
 id INT,
 first_name VARCHAR(20), 
 last_name VARCHAR(50),
 birthday DATE,
 age TINYINT,
 active BOOL
 );
 INSERT INTO users2 (id, first_name, last_name, birthday, age, active)
 VALUES (1, 'Дмитрий', 'Иванов', '1986-02-18', 31, True);


============================================

create table orders (
    id INT UNSIGNED,
    product_id INT UNSIGNED,
    sale TINYINT UNSIGNED,
    amount DECIMAL(8,2)
);

insert into orders (id, product_id, sale, amount)
values
(1,245,0,230.50),
(2,17,15,999999.99),
(3,145677,21,1240.00);




============================================

create table films (
    id INT UNSIGNED,
    name VARCHAR(100),
    rating float UNSIGNED,
    CONSTRAINT rating_gte_0 CHECK (rating >= 0),
    CONSTRAINT rating_lte_10 CHECK (rating <= 10),
    country VARCHAR(2)
);

insert into films(id, name, rating, country)
values
(1,"Большая буря",3.45,"RU"),
(2,"Игра",7.5714,"US"),
(3,"Война",10.0,"RU");
============================================

create table users (
    id INT UNSIGNED,
    email VARCHAR(100),
    date_joined DATE,
    last_activity DATETIME
);

insert into users (id,email,date_joined,last_activity)
values
(1,"user1@domain.com","2014-12-12","2016-04-08 12:34:54"),
(2,"user2@domain.com","2014-12-12","2017-02-13 11:46:53"),
(3,"user3@domain.com","2014-12-13","2017-04-04 05:12:07");

============================================
create table users (
    id INT UNSIGNED NOT NULL,
	email VARCHAR(20) NOT NULL

============================================

create table articles (
    id INT UNSIGNED NOT NULL,
	name VARCHAR(80),
    text TEXT,
    state ENUM("draft","correction","public")
);

============================================
select name,price,country from products where category_id IS NOT NULL and (find_in_set("RU",country) or find_in_set("BY",country))
order by price desc


============================================
created DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
amount MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,

============================================
id INT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT


============================================
create table passports (
    series VARCHAR(4) NOT NULL,
    number VARCHAR(6) NOT NULL,
    user_id INT UNSIGNED NOT NULL,
    date_issue DATE,
    primary key(series,number)
);

============================================
delete from orders where id in (3,4,7)


============================================
UNIQUE KEY passport (series,number)

создаем уникальный индекс
passport - имя
series,number - поля, которые не должны повторяться (два поля вместе не должны повторяться, по отдельности можно)


============================================
INDEX marks_index (mark)  - при создании таблицы

CREATE INDEX marks_index ON cars(mark) - добавление индекса (cars - таблица, mark - стобец)

CREATE UNIQUE INDEX marks_index ON cars(mark) - добавление уникального индекса (cars - таблица, mark - стобец) - зписи в колонке повторяться не могут.

DROP INDEX marks_index ON cars - удалить индекс

============================================

ALTER TABLE USERS
ADD COLUMN BIRTHDAY DATE NULL DEFAULT NULL  - добавление в таблицу новой колонки

ALTER TABLE USERS
DROP COLUMN BIRTHDAY - удаление колонки


============================================
ALTER TABLE USERS
MODIFY first_name VACHAR(50)  - меняем столбец

Каждый раз изменяя столбец нужно писать полное его описание как при создании этого стобца
============================================
ALTER TABLE USERS
change nmae name VACHAR(50) not null default '' - изменение имени столбца с nmae на name


============================================
RENAME TABLE product TO products; - переименование таблицы
rename table wp_users to blog_users, wp_posts to blog_posts, wp_comments to blog_comments - несколько таблиц разом

============================================

Сравнение строк с помощью равенства происходит без учета регистра.

Без использования доп параметров LIKE работает также как и равенство

LIKE BINARY - с учетом регистра

where name LIKE "Ю%" - отбор всех строк, где имя начинается с "Ю" (% соответствует любому количеству символов, в том числе нулю)

where name LIKE "Юр_" - отбор всех строк, где имя начинается с "Юр" и содержит в конце еще только 1 символ(_ соответствует одному символу)

============================================
https://dev.mysql.com/doc/refman/8.0/en/fulltext-boolean.html

Для использования полнотекстового поиска сначала нужно создать полнотекстовый индекс

CREATE FULLTEXT INDEX idx_name on products(name);

Теперь можно отбирать
----------------------------
Select * from products
where MATCH(name) AGAINST ('микроволновая печь')
----------------------------

Будут выданы результаты запросы в которых есть хотя бы одно из слов.
Отсортированы по релевантности. Сверху самые подходящие.


Можно включить продвинутый вариант поиска - добавляем IN BOOLEAN MODE и сможем использовать параметры.

+ возле слова означает, что слово точно должно быть в колонке по которой отбор:

------------------------------
Select * from products
where MATCH(name) 
AGAINST ('+микроволновая +печь' IN BOOLEAN MODE)
------------------------------

По аналогии минус значит что слова быть не должно.

Есть еще тильда (~). Она слово не удаляет из поиска, но значимость его снижает, что сказывается на результатах сортировки.



Полнотекстовые индексы можно создавать сразу по нескольким столбцам.
Для этого нужно указать все колонки в скобках через запятую.
Например так можно создать индекс search по названию и описанию:

CREATE FULLTEXT INDEX search ON products(name, description);
Так как индекс создается по нескольким столбцам, то при поиске в конструкции MATCH надо перечислить их все:
SELECT * FROM products 
WHERE MATCH(name, description) AGAINST ('платье детское');




можно искать по шаблону (*)
============================================
MATH in SQL http://www.mysql.ru/docs/man/Mathematical_functions.html
---------
ROUND(number) - округление до целого
ROUND(number, 3) - округление до трех цифр после запятой
TRUNCATE(number,1) - отсекает (8.985 -> 8.9)
FLOOR(number) - возвращает нижнее целое значение (8.9 -> 8)
CEILING(number) - возвращает верхнее целое число (8.1 -> 9)
ABS(number) - модуль
MOD(a,b) - остаток от деления a на b



============================================
Strings in SQL https://dev.mysql.com/doc/refman/8.0/en/string-functions.html
----------------
LENGTH(name) - количество байт в строк
CHAR_LENGTH(name) - длина строки.
CONCAT(string1,string2) - склеивание строк
CONCAT_WS(separator,string1,string2) - конкатенация с разделителем
LEFT(string,2) - берет 2 символа слева от string
RIGHT(string,2) - берет 2 символа справа от string
UPPER(string) - переводит с троку в верхний регистр
TRIM(str) - удаляет пробелы в начале и конце строки (есть отдельно LTRIM,RTRIM)


TRIM([{BOTH | LEADING | TRAILING} [remstr] FROM] str), TRIM([remstr FROM] str)

Returns the string str with all remstr prefixes or suffixes removed. If none of the specifiers BOTH, LEADING, or TRAILING is given, BOTH is assumed. remstr is optional and, if not specified, spaces are removed.


mysql> SELECT TRIM('  bar   ');
        -> 'bar'
mysql> SELECT TRIM(LEADING 'x' FROM 'xxxbarxxx');
        -> 'barxxx'
mysql> SELECT TRIM(BOTH 'x' FROM 'xxxbarxxx');
        -> 'bar'
mysql> SELECT TRIM(TRAILING 'xyz' FROM 'barxxyz');
        -> 'barx'
-----------

LPAD(str,len,padstr)

Returns the string str, left-padded with the string padstr to a length of len characters. If str is longer than len, the return value is shortened to len characters.


mysql> SELECT LPAD('hi',4,'??');
        -> '??hi'
mysql> SELECT LPAD('hi',1,'??');
        -> 'h'




SUBSTRING_INDEX(str,delim,count)

Returns the substring from string str before count occurrences of the delimiter delim. If count is positive, everything to the left of the final delimiter (counting from the left) is returned. If count is negative, everything to the right of the final delimiter (counting from the right) is returned. SUBSTRING_INDEX() performs a case-sensitive match when searching for delim.

mysql> SELECT SUBSTRING_INDEX('www.mysql.com', '.', 2);
        -> 'www.mysql'
mysql> SELECT SUBSTRING_INDEX('www.mysql.com', '.', -2);
        -> 'mysql.com'
============================================
Функции Даты 
--------------
https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html
https://www.w3schools.com/sql/func_mysql_date_format.asp



SELECT * from users
where date_joined > NOW() - INTERVAL 7 DAY; - пользователи, подключившиеся за последние 7 дней


DATE_FORMAT(date, "%d.%m.%Y %H:%i") - вывод даты в виде день.месяц.год часы:минуты

ORDER BY transactions.date - сортировка по полю date в изнаальной табличке

SUBDATE(date,INTERVAL expr unit), SUBDATE(expr,days)

When invoked with the INTERVAL form of the second argument, SUBDATE() is a synonym for DATE_SUB(). For information on the INTERVAL unit argument, see the discussion for DATE_ADD().


mysql> SELECT DATE_SUB('2008-01-02', INTERVAL 31 DAY);
        -> '2007-12-02'


============================================
Группировка данных. Функции аггрегации

https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html
-------------

select YEAR(date) as year, MONTH(date) as month ,SUMM(amount) as income,COUNT(*) as orders from orders
where status = "success"
GROUP BY 
	YEAR(date),
	MONTH(date)
order by year, month

Для отбора по уже сгруппированным полям используется HAVING



============================================



============================================



============================================











